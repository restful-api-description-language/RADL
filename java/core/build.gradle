apply plugin: 'osgi'

configurations {
  rnc
  springWeb
  compile.extendsFrom springWeb
}

dependencies {
  springWeb 'org.springframework:spring-web:4.0.3.RELEASE'
  compile 'commons-lang:commons-lang:2.6',
      "net.sf.saxon:Saxon-HE:$saxonVersion", 
      // TODO: Java 7 only   'jgraphx:jgraphx:3.0.1.1', 
      'isorelax:isorelax:20030108', 
      'commons-lang:commons-lang:2.6',
      'org.jsoup:jsoup:1.8.2'
  compile('com.thaiopensource:jing:20091111') {
    exclude module: 'xml-apis'
    exclude module: 'saxon', group: 'net.sf.saxon'
  }
  rnc('com.thaiopensource:trang:20091111') {
    exclude module: 'xml-apis'
    exclude module: 'saxon', group: 'net.sf.saxon'
  }
  compile('jaxen:jaxen:1.1.6') {
    exclude module: 'xml-apis'
  }
}

sourceSets {
  main {
    resources {
      srcDir project.rootProject.file('specification')
    }
  }
}

def examples = project.rootProject.fileTree(dir: 'specification/examples', include: '**/*.radl')
def schemaRnc = project.rootProject.file('specification/schema/radl.rnc')
def schemaXsd = new File(buildDir, 'xsd/radl.xsd')

task translateRncToXsd(type: JavaExec) {
  main = 'com.thaiopensource.relaxng.translate.Driver'
  args = ['-I', 'rnc', '-O', 'xsd', schemaRnc.path, schemaXsd.path]
  classpath configurations.rnc
  
  doFirst {
    errorOutput = new FileOutputStream(new File(buildDir, 'rnc2xsd.out'))
    schemaXsd.parentFile.mkdirs()
    new File(schemaXsd.parentFile, 'README.txt').withWriter { writer ->
      writer.println '''WARNING: These XML Schema files are automatically generated from the normative Relax NG schemas
and may not in all cases be accurate. They are provided as a service only. Use at your own risk.'''
    }
  }
}

jar {
  dependsOn translateRncToXsd
  from schemaXsd.parentFile.path, {
    into 'schema/xsd'
  }
}

task validateRadl(type: JavaExec, dependsOn: 'jar') {
  main = 'radl.core.validation.RadlValidator'
  args examples*.path
  classpath jar.archivePath, configurations.runtime
}

check.dependsOn 'validateRadl'

task radl2documentation(type: JavaExec, dependsOn: 'validateRadl') {
  main = 'radl.core.documentation.DocumentationGenerator'
  args new File(project.docsDir, 'clientDoc').path
  args examples*.path
  classpath jar.archivePath, configurations.runtime
  doFirst {
    errorOutput = new FileOutputStream(new File(buildDir, 'radl2doc.out'))
  }
}

assemble.dependsOn 'radl2documentation'

task integrationTest(dependsOn: 'jar') << {
  examples.each { radlFile ->
    def example = radlFile.name.substring(0, radlFile.name.indexOf('.'))
    println "* $example"
    def exampleDir = new File(buildDir, "integrationTest/$example")
    
    def baseDir = new File(exampleDir, 'spring')
    println '  - Generate Spring server code'
    ant.delete(dir: baseDir, failonerror: false)
    ant.java(classname: 'radl.java.generation.spring.RadlToSpringServer') {
      arg(line: "$radlFile.path $baseDir.path radl.${example.replaceAll('[^a-zA-Z0-9_]+', '_')}.rest")
      classpath {
        pathelement(location: jar.archivePath)
        pathelement(path: configurations.runtime.asPath)
      }
    }
    
    println '  - Compile generated code'
    ant.javac(srcdir: baseDir.path, includeantruntime: false) {
      classpath {
        pathelement(path: configurations.springWeb.asPath)
      }
    }

    println '  - Extract RADL from generated code'
    def generatedRadlFile = new File(exampleDir, "${example}.radl")
    def argumentsFile = new File(exampleDir, 'extract.arguments')
    argumentsFile.withWriter { writer ->
      writer.println "service.name = $example"
      writer.println "base.dir = $baseDir.path"
      writer.println "radl.file = $generatedRadlFile.path"
      writer.println "classpath = ${configurations.runtime.asPath}${File.pathSeparator}${jar.archivePath}"
      writer.println "java.version = $project.sourceCompatibility"
    }
    def outputFile = new File(exampleDir, 'extract.out')
    ant.java(classname: 'radl.java.extraction.FromJavaRadlExtractor', failonerror: 'true', output: outputFile.path) {
      arg(line: "@$argumentsFile.path")
      classpath {
        pathelement(location: jar.archivePath)
        pathelement(path: configurations.runtime.asPath)
      }
    }
    outputFile.eachLine { line -> 
      println "      $line"
    }
    
    println '  - Compare original RADL to extracted one'
    outputFile = new File(exampleDir, 'compare.out')
    ant.java(classname: 'radl.core.extraction.RadlDiff', error: outputFile.path, fork: true, failonerror: false,
        resultproperty: 'compareResult') {
      arg(line: "$radlFile.path $generatedRadlFile.path")
      classpath {
        pathelement(location: jar.archivePath)
        pathelement(path: configurations.testRuntime.asPath)
      }
    }
    outputFile.eachLine { line -> 
      println "      $line"
    }
    if (!outputFile.text.isEmpty()) {
      throw new GradleException("Extracted RADL doesn't match original RADL")
    }
  }
}

def relative(project, file) {
  file.canonicalPath.substring(project.projectDir.canonicalPath.length() + 1)
}


jar {
  manifest {
    name = 'radl-core'
    symbolicName = 'radl-core'
  }
}

task testValidation(type: Test) {
  include 'radl/core/validation/LintValidatorTest.class'
  workingDir = project.rootProject.projectDir
  testLogging {
    showStandardStreams = true 
    exceptionFormat 'full'
    maxGranularity = 3
  } 
}

test {
  systemProperty 'radl.dir', project.rootProject.projectDir
}

task testDocumentation(type: Test) {
  include 'radl/core/documentation/DocumentationTest.class'
  workingDir = project.rootProject.projectDir
  testLogging {
    showStandardStreams = true 
    exceptionFormat 'full'
    maxGranularity = 3
  } 
}
