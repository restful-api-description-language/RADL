<?xml version="1.0" encoding="utf-8"?>
<article xmlns="http://docbook.org/ns/docbook"
	 xmlns:xl="http://www.w3.org/1999/xlink"
	 version="5.0" xml:lang="en">
  <info>
    <title>RESTful API Description Language (RADL)</title>
    <subtitle>Hypermedia-driven API design</subtitle>

    <author>
      <personname>Jonathan Robie</personname>
      <email>jonathan.robie@emc.com</email>
    </author>

    <author>
      <personname>Rémon Sinnema</personname>
      <email>remon.sinnema@emc.com</email>
    </author>

    <author>
      <personname>Erik Wilde</personname>
      <email>erik.wilde@emc.com</email>
    </author>

    <keywordset>
      <keyword>REST</keyword>
      <keyword>XML</keyword>
      <keyword>authoring</keyword>
      <keyword>metadata</keyword>
    </keywordset>

    <abstract>
      <para>RESTful API Description Language (RADL) is an XML vocabulary for
      describing Hypermedia-driven RESTful APIs. The APIs it describes may
      use any media type, in XML, JSON, HTML, or any other format. The
      structure of a RADL description is based on media types, including the
      documents associated with a media type, links found in these
      documents, and the interfaces associated with these links.</para>

      <para>RADL can be used as a specification language or as run-time
      metadata to describe a service.</para>

      <para>This is a preliminary version of an article that
      will be presented at XML Prague 2014. The most recent version of this specification is always
      available at <ulink url="https://github.com/restful-api-description-language">http://github.com/restful-api-description-language</ulink>.</para>

    </abstract>
    <legalnotice>
      <copyright><year>2014</year><holder>EMC Corporation</holder></copyright>
 
      <para>Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at</para>

      <ulink uri="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</ulink>

      <para>Unless required by applicable law or agreed to in writing,
      software distributed under the License is distributed on an "AS
      IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
      express or implied.  See the License for the specific language
      governing permissions and limitations under the License.</para>
      
    </legalnotice>

  </info>

  <section>
    <title>Introduction</title>

    <para>Web APIs are critical to the business strategy of many
    companies, and vital to the way users use information on the
    Web. Companies like eBay, Amazon, Salesforce, and Google provide
    valuable services via Web APIs, and developers are using these APIs
    together with other data sources to create new kinds of applications
    that run on a variety of devices and environments. Some analysts are
    now writing about the API Economy, and even people who have never
    programmed may know why Web APIs are important.</para>

    <para>Web service providers may have little knowledge of the
    clients that use them, but they need to ensure that these clients
    can continue to run as they evolve their services. Web services
    may need to support large numbers of users, so they must be
    scalable. This means that Web API providers must design their APIs
    to support evolution and scalablility in distributed systems. This
    is not easy.</para>x

    <para>Fortunately, this is precisely the problem that REST
    (Representational State Transfer) was designed to
    solve. Unfortunately, designing and documenting RESTful APIs is still
    too much of a black art, causing many difficulties for the average
    developer. An XML vocabulary that supports the design process is
    extremely helpful for designing a RESTful API and for teaching RESTful
    API design, and is well suited to writing documentation.</para>

    <para>Developers who write clients need documentation to know how to use Web
    APIs. Their programs may need a machine-readable representation of the
    API as runtime metadata. An XML vocabulary works well for this, and
    can easily be converted to JSON and HTML for developers who prefer
    this representation.</para>

    <para>RESTful API Description Language (RADL) is an XML vocabulary
    created to support RESTful Web API design. It can be used to create
    both documentation and runtime metadata. The design of RADL is focused
    on the media type, in keeping with this famous quote by Roy
    Fielding <xref linkend="hypertext-driven"/>:</para>

    <blockquote><para>Any effort spent describing what methods to use
    on what URIs of interest should be entirely defined within the
    scope of the processing rules for a media type.</para></blockquote>

    <para>RADL provides much the same information as Web Application
    Description Language (WADL)
    but the structure of WADL is driven
    by URI patterns and server-side implementation concerns rather than
    hypermedia-driven design. RADL provides much the same information as
    RESTful Service Description Language (<xref linkend="RSDL2"/>), 
    <footnote><para>Here, RSDL refers to <xref linkend="RSDL2"/>, the
    language we presented at Balisage 2013.  Unfortunately, we found
    that the name and the acronym were previously used by Red Hat for
    a different language, <xref linkend="RSDL1"/>, which concentrates
    on describing URIs as standalone entry points for an
    application.</para></footnote>,
    but the structure of RSDL is driven by resources, describing an
    implementation rather than focusing on the media-types.</para>


  </section>

  <section>
    <title>REST</title>

    <para>REST Is an Architectural Style, which is formally defined by the
    following constraints:</para>

    <orderedlist>
      <listitem><para>Client/Server</para></listitem>
      <listitem><para>Stateless</para></listitem>
      <listitem><para>Cache</para></listitem>
      <listitem><para>Uniform interface</para></listitem>
      <listitem><para>Layered system</para></listitem>
      <listitem><para>Code-on-demand (optional)</para></listitem>
    </orderedlist>

    <para>The client/server constraint demands that we divide our system
    in multiple components, since monolithic applications cannot be made
    to scale. Each component can be further divided as needed. For
    instance, the client can be a browser and the server a web
    application. We can then further divide the web application into a web
    server for the CPU-intensive processing and a database server for
    I/O-intensive processing. Distributing capabilities over multiple
    components gives us the opportunity to give each the resources it
    needs.</para>

    <para>The layered system constraint additionally requires that the
    client cannot see beyond its immediate server. This allows us to
    change our server landscape without breaking the client. We could, for
    example, insert proxy servers to aid with scaling.</para>

    <para>We can further improve scalability by moving some of the
    processing from the server to the client. The stateless constraint
    makes us move data to the client so that the server need not maintain
    application state. Here, we must distinguish two different kinds of
    state: the server will maintain resource state, so that interesting
    data is available from multiple clients, but the client is responsible
    for application state. The client knows what goal it wants to achieve
    and can easily remember where along the path to that goal it is.
    </para>

    <para>The code-on-demand constraint additionally pushes processing to
    the client. We see this when web servers send JavaScript to the
    browser, which then executes it. This optional constraint is very
    common on the Web, but less common in RESTful APIs.</para>

    <para>The cache constraint also helps with scalability. The server
    indicates how long data that it sends is valid, so that the client
    does not have to keep asking for it. If clients do so anyway, we can
    insert caching proxy servers to keep our servers available for useful
    work.</para>

    <para>The uniform interface constraint is the one that really distinguishes
    REST from other approaches. Anybody who has played with Legos knows
    the power of a universal interface. In REST over HTTP, we capture all
    actions with the standard HTTP methods.</para>
  </section>

  <section>
    <title>How we designed RADL</title>

    <para>We designed RADL by refactoring RSDL to define almost everything in
    terms of media types. In RSDL, we focused on describing services. In
    RADL, we focus on describing media types. This shift was motivated by
    the Roy Fielding quote cited in the introduction  <xref linkend="hypertext-driven"/>:</para>

    <blockquote><para>Any effort spent describing what methods to use
    on what URIs of interest should be entirely defined within the
    scope of the processing rules for a media
    type.</para></blockquote>


    <para>The structure of a REST API is based on media types,
    including the documents associated with a media type, links found
    in these documents, and the interfaces associated with these
    links.  This is also the structure of a RADL description. A
    client's current application state, including the choices
    available to the client, is found in documents that are described
    by a media type.  The client needs to understand the media type in
    order to identify available choices and make use of them. In <xref
    linkend="hypertext-driven"/>, Fielding explains how a client uses
    this kind of API:</para>

    <blockquote><para>A REST API should be entered with no prior
    knowledge beyond the initial URI (bookmark) and set of
    standardized media types that are appropriate for the intended
    audience (i.e., expected to be understood by any client that might
    use the API). From that point on, all application state
    transitions must be driven by client selection of server-provided
    choices that are present in the received representations or
    implied by the user’s manipulation of those representations. The
    transitions may be determined (or limited by) the client’s
    knowledge of media types and resource communication mechanisms,
    both of which may be improved on-the-fly (e.g.,
    code-on-demand). [Failure here implies that out-of-band
    information is driving interaction instead of
    hypertext.]</para></blockquote>

    <para>These are the things that a client needs to know to use a
    REST API, so these are the things that RADL must describe.  To
    design RADL, we collecting the formal definitions of the entities
    we needed to model, identifying their relationships in the
    documents that define them, and faithfully preserving these
    relationships in our schema.  A RADL description is a description
    of a service, using the following definition <footnote><para>This
    definition is taken from a Twitter tweet by Erik Wilde, 21 August
    2013.</para></footnote>:</para>

    <blockquote><para>A service is a set of interlinked resources that
    allows clients to reach goals by following links with explicit
    interaction semantics.</para></blockquote>

    <para>Once a complete media type description is done, the resource
    description for a service is simple and small, associating URI formats
    with interfaces that are defined in the media type descriptions.</para>

    <para>Fielding's thesis refers to (the now obsoleted) <xref linkend="rfc2048"/> for the definition of media type.</para>

    <blockquote><para>A media type is a precise and openly available specification of
    the data format of a representation.</para></blockquote>

    <para>A media type defines how a sequence of bytes is to be interpreted as
    data. For instance, the JPEG specification defines how images of
    photographic quality are to be coded. A browser uses this knowledge to
    draw images on screen.</para>

    <blockquote><para>A media type is used to indicate the semantics
    of the bytes that make up the data.</para></blockquote>

    <para>Not only does a media type define the layout of the data, it
    also defines the semantics, or how to process the data. For instance,
    the XML specification defines when a document is well-formed and valid
    and what whitespace is significant.</para>

    <para>For services that we design, we usually want to present
    structured information, so the layout of the data is generally defined
    in terms of structured formats like XML or JSON. They can be generic,
    like XML, or more tailored to a specific field, like XACML
    (application/xacml+xml) for access control. They can even be specific
    to a single service, such as Documentum
    (<code>application/vnd.emc.documentum+xml</code>). However, media
    types can also be unstructured, like JPEG
    (<code>image/jpeg</code>). RADL needs to be able to support both
    structured and unstructured media types. A media type may define more
    than one kind of document. The Atom Syndication Format defines feed
    and entry documents, for example. A complex custom RESTful service
    might define many more kinds of documents.</para>

    <para>The second job of a media type is to define semantics, or how to
    process the data. In REST, the client maintains application state and
    drives the interactions with the server, so the server can only guide
    it by exposing where the client can go next, providing a set of
    options in the form of hypermedia links. These links are typed via
    link relations that identify the relationship between the source and
    target resource. This is why the semantics of a service are defined
    primarily by the semantics of the hypermedia.</para>

    <para>Since any RESTful API must limit its operations to the uniform
    interface, we need to do nothing more than decide which subset of the
    uniform interface to expose. In practice, this means we must select
    which of the standard HTTP methods to support, and define the
    conventions for those methods in the context of a given media
    type. These conventions include methods that can be applied to a URI
    that implements each interface, together with any URI parameters,
    headers, and request bodies used when making these requests.</para>

    <para>A service description contains a few items that are needed to
    implement the service but are not needed by the client. Resource
    descriptions are the most common example. This kind of information
    generally should not be provided to clients, because developers may be
    tempted to write clients that depend on it, resulting in more tightly
    coupled systems. A service description can also contain items that are
    needed by both the client and the implementation, but are orthogonal
    to the media types. Authentication is the most common example. This
    information must be provided to the user, but not as part of the media
    type. RADL allows the entire service description to be specified in
    one document. The information needed for client documentation, server
    stub generation, runtime metadata, and testing can then be extracted
    from the complete description as needed.</para>

  </section>

  <section>
    <title>The RADL document</title>

    <para>Now that we have defined the concepts behind RADL, let us show how
    they are modeled in a RADL document. The following template
    illustrates the overall structure of RADL (a RELAX-NG schema can be
    found in <xref linkend="appendix-a"/>):</para>

    <programlisting><![CDATA[
<service name="Outline" xmlns="http://identifiers.emc.com/vocab/radl"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://github.com/restful-api-description-language/RADL/tree/master/schema"
    radl.xsd">

  <link-relations>
    <!-- Link relations used by all media types -->
  </link-relations>

  <media-types>
    <!-- Media types used by all resources -->
    <media-type>
      <documents>
        <!-- The kinds of documents defined by this media type -->
      </documents>
      <interfaces>
        <!-- The behavior defined by this media type -->
      </interfaces>
    </media-type>
  </media-types>

  <resources>
    <!-- Resources that make up the service -->
    <!-- Resources implement interfaces of media types -->
  </resources>
  
</service>
]]></programlisting>

<para>The document element is service. It contains elements that model the
main concepts we discussed in the previous section: link relations,
media-types, and resources. Media types contain documents that
describe the data format and interfaces that describe the semantics.</para>

<para>Now let us provide a concrete example, taken from chapter 5 of the
book RESTful Web Services. This chapter deals with the read-only
aspects of a service that provides information about places. The next
chapter then goes on to add mutability. Since that does not change
anything about the way we capture information in RADL, we will
confine ourselves to chapter 5 here in order to keep the example
short.</para>

<programlisting><![CDATA[
<service name="Maps" xmlns="http://identifiers.emc.com/vocab/radl"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://identifiers.emc.com/vocab/radl radl.xsd"
    xmlns:html="http://www.w3.org/1999/xhtml/">

  <documentation>
    This is an example based on chapter 5 of the book 
    <ref uri="http://shop.oreilly.com/product/9780596529260.do">RESTful Web Services</ref>.
  </documentation>
]]></programlisting>

<para>This starting fragment shows how we can add documentation to
RADL. We support different documentation modules. Our TechPubs
department uses DocBook, for instance, but in this paper we will only
use HTML. To keep the RADL document well-formed XML, we will use XHTML
and we declare its namespace. We can use all of HTML's elements and
additionally we can use the <code>ref</code> element to refer to
things. We added <code>ref</code>so that we could refer to RADL
concepts, like link relations, and more easily process those
references. Working with only generic <code>a</code> elements would be
awkward.</para>


<programlisting><![CDATA[
  <link-relations>
    <link-relation id="rel-place" name="place">
      <documentation>
        The target resource is a place related to the current resource.
      </documentation>
    </link-relation>
    <link-relation id="rel-point" name="point">
      <documentation>
        The target resource is a point on a planet related to the current resource. 
      </documentation>
    </link-relation>
    <link-relation id="rel-map" name="map">
      <documentation>
        The target resource is a map related to the current resource. 
      </documentation>
    </link-relation>
    <link-relation id="rel-image" name="image">
      <documentation>
        The target resource is an image related to the current resource.
      </documentation>
    </link-relation>
  </link-relations>
]]></programlisting>

<para>This example uses only link relations that were invented for this
service, but you could add more generic ones, like <code>self</code> as well.</para>

<para>There is no defined model for naming link relations. All the generic
ones like <code>self</code> use simple names, and they are registered by IANA in a
flat namespace. However, to avoid name collisions, you may want to use
URIs for your own specialized link relations. EMC is moving towards
using URIs of the form <code>http://identifiers.emc.com/linkrel/&lt;name&gt;</code>.</para>

<para>The next section defines the media types. The first media type used in
this service is PNG. It is used for displaying images of maps of
places. This media type defines only one kind of document and one
interface. Since this chapter of the book deals with a read-only
service, all you can do with the images is retrieve them through the
GET method.</para>


<programlisting><![CDATA[

  <media-types>
    <media-type id="med-png" name="image/png">
      <description type="html" href="http://www.iana.org/assignments/media-types/image/png"/>
      <documents>
        <document id="doc-png" name="png"/>
      </documents>
      <interfaces>
        <interface id="int-image" name="image">
          <methods>
            <method name="GET">
              <request>
              </request>
              <response>
                <document ref="doc-png"/>
              </response>
            </method>
          </methods>
        </interface>
      </interfaces>
    </media-type>
    !!! SNIP !!!
]]></programlisting>

<para>The next media type is the one that is defined specifically for
this service. It is based on XHTML. The author could have defined its
own media type, say <code>application/vnd.oreilly.maps+xml</code>, but
decided against that, and extends the
<code>application/xhtml+xml</code> media type instead. The HTML part
of the media type makes it easy to consume the service with generic
clients like web browsers. The X part of the media type also makes it
possible to consume the service with a special-purpose client. For
those types of clients, it would probably have been easier to use a
new vocabulary, but then you would loose the browsers. Every service
has to weigh the pros and cons. In the services that EMC provides,
general purpose clients can provide very little value, so we create
new media types like <code>application/vnd.emc.documentum+xml</code>
and build special purpose clients instead.</para>

<para>This media type defines several kinds of documents and
interfaces. It defines how to get from one document to another via
links that are typed using link relations. It also defines how these
documents can be processed using interfaces.</para>


<programlisting><![CDATA[
    <media-type id="med-planets" name="application/xhtml+xml">
      <documentation>
        We define an <ref uri="http://www.w3.org/TR/xhtml11/">XHTML</ref> <html:em>microformat</html:em> by adding 
        meaning using the <html:code>class</html:code> attribute to elements.
        For example, adding <html:code>class="planets"</html:code> to the <html:code>ul</html:code> element, we can 
        turn a generic list into a list of planets.
      </documentation>
      <description type="html" href="http://tools.ietf.org/html/rfc3236"/>
      <documents>
        <document id="doc-planets" name="planets">
          <links>
            <link link-relation-ref="rel-place" interface-ref="int-place">
              <documentation>
                 Links of this type are found by looking for <html:code>a</html:code> elements with 
                 <html:code>class="place"</html:code>. Additionally, you can find search links to places via the
                 <html:code>form</html:code> element with <html:code>id="searchPlace"</html:code>.
              </documentation>
            </link>
          </links>
        </document>
        <document id="doc-place" name="place">
          <links>
            <link link-relation-ref="rel-map" interface-ref="int-map">
              <documentation>
                Links of this type are found by looking for <html:code>a</html:code> elements with 
                <html:code>class="map"</html:code>.
              </documentation>
            </link>
            <link link-relation-ref="rel-point" interface-ref="int-point">
              <documentation>
                Links of this type are found by looking for <html:code>a</html:code> elements with different values for 
                the <html:code>class</html:code> attribute, like <html:code>coordinates</html:code>, 
                <html:code>map_nav</html:code>, <html:code>zoom_in</html:code>, and <html:code>zoom_out</html:code>.
              </documentation>
            </link>
            <link link-relation-ref="rel-place" interface-ref="int-place">
              <documentation>
                 Links of this type are found by looking for <html:code>a</html:code> elements with 
                 <html:code>class="place"</html:code>. Additionally, you can find search links to places via the
                 <html:code>form</html:code> element with <html:code>id="searchPlace"</html:code>.
              </documentation>
            </link>
          </links>
        </document>
        <document id="doc-point" name="point">
          <links>
            <link link-relation-ref="rel-place" interface-ref="int-place">
              <documentation>
                 Links of this type are found by looking for <html:code>a</html:code> elements with 
                 <html:code>class="place"</html:code>. Additionally, you can find search links to places via the
                 <html:code>form</html:code> element with <html:code>id="searchPlace"</html:code>.
              </documentation>
            </link>
            <link link-relation-ref="rel-point" interface-ref="int-point">
              <documentation>
                Links of this type are found by looking for <html:code>a</html:code> elements with different values for 
                the <html:code>class</html:code> attribute, like <html:code>coordinates</html:code>, 
                <html:code>map_nav</html:code>, <html:code>zoom_in</html:code>, and <html:code>zoom_out</html:code>.
              </documentation>
            </link>
          </links>
        </document>
        <document id="doc-map" name="map">
          <links>
            <link link-relation-ref="rel-image" interface-ref="int-image">
              <documentation>
                 Links of this type are found by looking for <html:code>img</html:code> elements with
                 <html:code>class="map"</html:code>.
              </documentation>
            </link>
            <link link-relation-ref="rel-map" interface-ref="int-map">
              <documentation>
                Links of this type are found by looking for <html:code>a</html:code> elements with 
                <html:code>class="map"</html:code>.
              </documentation>
            </link>
          </links>
        </document>
      </documents>
      <interfaces>
        <interface id="int-planets" name="planets">
          <methods>
            <method name="GET">
              <response>
                <document ref="doc-planets"/>
              </response>
            </method>
          </methods>
        </interface>

        <interface id="int-place" name="place">
          <methods>
            <method name="GET">
              <response>
                <document ref="doc-place"/>
              </response>
            </method>
          </methods>
        </interface>

        <interface id="int-point" name="point">
          <methods>
            <method name="GET">
              <response>
                <document ref="doc-point"/>
              </response>
            </method>
          </methods>
        </interface>

        <interface id="int-map" name="map">
          <methods>
            <method name="GET">
              <response>
                <document ref="doc-map"/>
              </response>
            </method>
          </methods>
        </interface>
      </interfaces>
    </media-type>
  </media-types>
]]></programlisting>

<para>The final section of the RADL document contains the implementation
details: the resources. A resource lives at a URI or URI
Template <xref linkend="rfc6570"/>. URI Templates define variables that sometimes are part of
the interface, but to keep things simple we do not show that in this
paper. Resources implement interfaces. In this example the
correspondence is 1:1, so that's not very interesting, but there are
cases where it makes sense to let a resource implement more than one
interface.</para>

<programlisting><![CDATA[
  <resources>
    <resource id="res-planets" name="planets">
      <location uri="/"/>
      <interface ref="int-planets"/>
    </resource>

    <resource id="res-place" name="place">
      <location uri-template="/{planet}/[{scoping-information}/][{place-name}]{?show}"/>
      <interface ref="int-place"/>
    </resource>

    <resource id="res-point" name="point">
      <location uri-template="/{planet}/{latitude},{longitude}"/>
      <interface ref="int-point"/>
    </resource>

    <resource id="res-map" name="map">
      <location uri-template="/{map-type}{scale}/{planet}/{latitude},{longitude}"/>
      <interface ref="int-map"/>
    </resource>

    <resource id="res-image" name="image">
      <location uri-template="/{map-type}{scale}/{planet}/images/{latitude},{longitude}.png"/>
      <interface ref="int-image"/>
    </resource>
  </resources>

</service>
]]></programlisting>


<para>This short example does not show how to handle things like URI
parameters, HTTP headers and status codes, or authentication. All of these are possible in RADL.</para>

<note><para>TODO: provide examples to illustrate more RADL functionality.</para></note>
</section>
<section>
<title>Using RADL Descriptions</title>

<para>The following are some of the major uses we envision for RADL
descriptions.</para>

<itemizedlist>
<listitem><para>Generating client documentation using HTML or DocBook. An example of
generated documentation is shown in Appendix B, along with the
stylesheet that generated it. We are currently doing this for our
own interfaces.</para></listitem>


<listitem><para>Providing a standard representation of a service to
make it easier to review and to mentor REST API design. We have
successfully taught RESTful design to two teams with RSDL using this
approach.</para></listitem>

<listitem><para>Generating server stubs for the REST interfaces to ensure that the
deployed interface matches the specified interface.</para></listitem>

<listitem><para>Generating test clients to ensure that a running instance correctly
implements the specified interfaces. We have limited experience with
this using RSDL.</para></listitem>

<listitem><para>Providing run-time metadata, which may be generated
dynamically to allow multiple services to be combined, modify the
service based on available permissions or preferences, etc.  This
metadata may be provided in either XML or JSON+HTML (see Appendix C
for information on the JSON+HTML representation). For instance, a
service might provide run time metadata via the <code>about</code>
link relation from <xref linkend="json-home"/> or <xref
linkend="xml-home"/>.</para></listitem>
</itemizedlist>
</section>
<section xml:id="appendix-a">
<title>Appendix A: RADL Schema</title>

<para>The RADL schema is a RELAX-NG compact notation schema that allows
documentation to be embedded using a separate documentation
schema. This appendix shows sample documentation schemas for XHTML and
DocBook, then shows the schema for RADL per se.</para>

<para>This schema is current as of the time of writing. For the latest
version, see the RADL github repository at <ulink uri="https://github.com/restful-api-description-language">https://github.com/restful-api-description-language</ulink>.</para>
</section>
<section>
<title>Schema for embedded XHTML</title>

<programlisting><![CDATA[
namespace ns1 = "http://www.w3.org/1999/xhtml/"

documentation = element documentation { inline?, doc-title?, html }
inline = attribute inline { "true" | "false" }
doc-title = element title { text }
html = html-content*
html-content = html-element | text | ref
html-element = element ns1:* { html-attribute*, html-content* }
html-attribute = attribute * { text? }
]]></programlisting>
</section>
<section>
<title>Schema for embedded DocBook</title>

<programlisting><![CDATA[
namespace docbook = "http://docbook.org/ns/docbook"

documentation = element documentation { inline?, doc-title?, docbook }

inline = attribute inline { ( "true" | "false" ) }
doc-title = element title { text }

docbook =  docbook-content*
docbook-content = (docbook-element | text | ref)
docbook-element = element docbook:* { docbook-attribute*, docbook-content* }
docbook-attribute = attribute * { text? }
]]></programlisting>
</section>

<section>
<title>RADL schema</title>

<programlisting><![CDATA[
default namespace radl = "http://identifiers.emc.com/radl"

start = service
include "ref.rnc"
include "documentation.rnc"
service =
  element service {
    id?,
    name,
    documentation?,
    service-start?,
    link-relations?,
    link-types?,
    service-conventions?,
    media-types?,
    resources?,
    authentication?
  }
# Generic definitions
id = attribute id { xsd:ID }
idref = attribute ref { xsd:IDREF }
title = element title { text }
name = attribute name { text }
href = attribute href { xsd:anyURI }
ref-attribute = attribute ref { xsd:IDREF }
foreign-element =
  element * - radl:* { any-attribute*, (foreign-element* | text)* }
any-attribute = attribute * { text? }
public = attribute public { "true" }
status = implementation-status?, design-status?
implementation-status =
  attribute implementation-status {
    "future" | "assigned" | "poc" | "partial" | "complete" | "passed"
  }
design-status =
  attribute design-status {
    "future" | "assigned" | "poc" | "partial" | "complete" | "approved"
  }
service-start = element start { href?, interface-ref, identity-provider-ref? }
identity-provider-ref = attribute identity-provider-ref { xsd:IDREF }
link-relations =
  element link-relations { documentation?, link-relation* }
link-relation =
  element link-relation {
    documentation?, id, status, link-relation-name, href? 
  }
link-relation-name = attribute name { xsd:anyURI }
link-relation-ref = attribute link-relation-ref { xsd:IDREF }
link-types = element link-types { documentation?, link-type* }
link-type =
  element link-type { documentation?, id, status, name?, href?, path? }
path = attribute path { xsd:string }
service-conventions = element conventions { documentation?, headers?, uri-parameters?, status-codes? }
media-types = element media-types { documentation?, media-type* }
media-type =
  element media-type {
    id?,
    (href
     | (media-type-extends?,
        name,
        documentation?,
        description*,
        documents?,
	media-type-conventions?,
	interfaces?))
  }
media-type-ref = attribute media-type-ref { xsd:IDREF }
media-type-extends = attribute extends { xsd:anyURI }
description = element description { type, href, documentation? }
type =
  attribute type {
    "rnc" | "rng" | "xsd" | "JSONSchema" | "sedola" | "text" | "html"
  }
documents = element documents { document* }
document =
  element document {
    (id?,
     extends?,
     name,
     documentation?,
     properties?,
     links?,
     document*)
    | ref-attribute
  }
document-ref =
  element document {
    attribute ref { xsd:IDREF },
    documentation?
  }
media-type-conventions = element conventions { documentation?, headers?, uri-parameters?, status-codes? }
properties = element properties { documentation?, property* }
property = element property { id?, name, documentation? }
links = element links { documentation?, link* }
link =
  element link {
    (link-relation-ref | link-type-ref),
    interface-ref,
    status?,
    documentation?
  }
link-type-ref = attribute link-type-ref { xsd:IDREF }
interfaces =
  element interfaces {
    interface-conventions?,
    interface*
  }
uri-parameters =
  element uri-parameters { documentation?, uri-parameter* }
uri-parameter =
  element uri-parameter {
    id?, name, documentation, datatype, value-range?, default-value?
  }
uri-parameter-ref = attribute uri-parameter-ref { xsd:IDREF }
interface-conventions = element conventions { documentation?, headers?, uri-parameters?, status-codes? }
interface = element interface { headers?, id?, name, methods }
interface-ref = attribute interface-ref { xsd:IDREF }
headers = element headers { header* }
header = element header { id?, name, header-type, documentation? }
header-type =
  attribute type { "request" | "response" | "general" | "entity" }
methods = element methods { method* }
method =
  element method { id?, method-name, status?, request?, response? }
method-name = attribute name { http-method }
http-method =
  "GET"
  | "PUT"
  | "HEAD"
  | "POST"
  | "DELETE"
  | "TRACE"
  | "OPTIONS"
  | "CONNECT"
  | "PATCH"
request =
  element request {
    documentation?, request-uri-parameters?, header-refs?, document-ref*
  }
request-uri-parameters =
  element uri-parameters { request-uri-parameter* }
request-uri-parameter =
  element uri-parameter {
    documentation?, id?, name?, request-uri-parameter-ref
  }
request-uri-parameter-ref = attribute ref { xsd:IDREF }
header-refs = element header-refs { documentation?, header-ref* }
header-ref = element header-ref { ref }
response =
  element response {
    documentation?, response-status-codes?, header-refs?, document-ref*
  }
response-status-codes =
  element status-codes {
    element status-code { ref }*
  }
status-codes = element status-codes { documentation?, status-code* }
status-code = element status { code, id, documentation?, http-problem? }
status-code-ref = attribute ref { xsd:IDREF }
code = attribute code { HTTP-status-enum }
HTTP-status-enum =
  "100"
  | "101"
  | "102"
  | "200"
  | "201"
  | "203"
  | "204"
  | "205"
  | "206"
  | "207"
  | "208"
  | "301"
  | "302"
  | "303"
  | "304"
  | "305"
  | "306"
  | "307"
  | "308"
  | "400"
  | "401"
  | "402"
  | "403"
  | "404"
  | "405"
  | "406"
  | "407"
  | "408"
  | "409"
  | "410"
  | "411"
  | "412"
  | "413"
  | "414"
  | "415"
  | "416"
  | "417"
  | "418"
  | "420"
  | "422"
  | "423"
  | "424"
  | "425"
  | "426"
  | "428"
  | "429"
  | "431"
  | "444"
  | "449"
  | "450"
  | "451"
  | "494"
  | "495"
  | "496"
  | "497"
  | "499"
  | "500"
  | "501"
  | "502"
  | "503"
  | "504"
  | "505"
  | "506"
  | "507"
  | "508"
  | "509"
  | "510"
  | "511"
  | "598"
  | "599"
http-problem =
  element problem { problemType, title, detail, supportId, more }
problemType = element problemType { xsd:anyURI }
detail = element detail { text }
supportId = element supportId { xsd:anyURI }
more = element more { foreign-element* }
resources = element resources { id?, documentation?, resource* }
resource =
  element resource {
    documentation?,
    id,
    name,
    identity-provider-ref?,
    public?,
    status?,
    extends?,
    location?,
    resource-interface*
  }
resource-ref = attribute resource-ref { xsd:IDREF }
extends = attribute extends { xsd:QName }
location = element location { documentation?, (uri | uri-template) }
uri-template = attribute uri-template { text }
resource-interface = element interface { ref-attribute }
authentication =
  element authentication { authentication-conventions?, mechanism*, identity-provider? }
authentication-conventions = element conventions { documentation?, headers?, status-codes? }
mechanism =
  element mechanism {
    id?, name, authentication-type, documentation?, scheme*
  }
mechanism-ref = attribute mechanism-ref { xsd:IDREF }
identity-provider = element identity-provider { id, mechanism-ref }
authentication-type = attribute authentication-type { text }
scheme = element scheme { id?, name, documentation?, scheme-parameter* }
scheme-parameter = element parameter { id?, name, documentation? }
datatype =
  attribute datatype {
    "string"
    | "boolean"
    | "decimal"
    | "float"
    | "double"
    | "duration"
    | "dateTime"
    | "time"
    | "date"
    | "hexBinary"
    | "base64Binary"
    | "anyURI"
    | "integer"
    | "language"
    | "ID"
    | "IDREF"
    | "integer"
    | "long"
    | "short"
    | "byte"
  }
value-range = element value-range { text }
default-value = element default { text }
uri = attribute uri { xsd:anyURI }
]]></programlisting>
</section>
<section>
<title>Appendix B: Generating HTML client documentation</title>

<note><para>TODO: stylesheet to generate HTML overview of a RADL service for client documentation.</para></note>
</section>
<section>
<title>Appendix C: Generating JSON+HTML metadata</title>
<note><para>TODO: stylesheet to convert RADL to the standard RADL JSON+HTML
representation</para></note>
</section>

  <bibliography>
    <title>Bibliography</title>
    <bibliomixed xml:id="WADL" xreflabel="WADL">Marc Hadley, Sun Microsystems. <emphasis role="ital"
        >Web Application Description Language</emphasis>, W3C Member Submission 31 August 2009.
        <link>http://www.w3.org/Submission/wadl/</link>.
    </bibliomixed>
    <bibliomixed xml:id="rfc6570" xreflabel="URI Templates">Joe Gregorio, Google; Roy Fielding,
      Adobe; Marc Hadley, MITRE; Mark Nottingham, Rackspace; David Orchard, Salesforce.com.
        <emphasis role="ital">URI Template</emphasis>, IETF RFC 6570, March 2012.
        <link>http://tools.ietf.org/html/rfc6570</link></bibliomixed>

    <bibliomixed xml:id="json-home" xreflabel="JSON Home Documents">Mark Nottingham, Rackspace.
        <emphasis role="ital">Home Documents for HTTP APIs</emphasis>, May 8, 2013.
        <link>http://www.ietf.org/id/draft-nottingham-json-home-03.txt</link></bibliomixed>

    <bibliomixed xml:id="xml-home" xreflabel="XML Home Documents">Erik Wilde, EMC. <emphasis
        role="ital">Home Documents for HTTP Services: XML Syntax</emphasis>, June 11, 2013.
        <link>http://www.ietf.org/id/draft-wilde-home-xml-01.txt</link></bibliomixed>


    <bibliomixed xml:id="rfc6838"
      xreflabel="Media Type
      Specifications and Registration Procedures">N. Freed, Oracle; J.
      Klensin; T. Hansen, AT&amp;T Laboratories. <emphasis role="ital">Media Type Specifications and
        Registration Procedures</emphasis>, IETF RFC 6838, January 2013.
        <link>http://tools.ietf.org/html/rfc6838</link></bibliomixed>

    <bibliomixed xml:id="rfc2048" xreflabel="RFC 2048">
      N. Freed, J. Klensin, J. Postel.
      <emphasis role="ital">Multipurpose Internet Mail Extensions
      (MIME) Part Four: Registration Procedures</emphasis>, IETF RFC 2048, November 1996.
      <link>http://tools.ietf.org/html/rfc2048</link>
    </bibliomixed>

    <bibliomixed xml:id="Burke" xreflabel="To WADL or not to WADL"> Bill Burke. <emphasis
        role="ital">To WADL or not to WADL</emphasis>, blog post, May 21, 2009.
        <link>http://bill.burkecentral.com/2009/05/21/to-wadl-or-not-to-wadl/</link>.</bibliomixed>
    <bibliomixed xml:id="hypertext-driven" xreflabel="REST APIs must be hypertext-driven"> Roy
      Fielding. <emphasis role="ital">REST APIs must be hypertext-driven</emphasis>, blog post, Mon
      20 Oct 2008.
        <link>http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven/</link>.</bibliomixed>

    <bibliomixed xml:id="draft-nottingham-json-home-02" xreflabel="Home Documents for HTTP APIs">
      <emphasis role="ital">Home Documents for HTTP APIs</emphasis>,
      http://tools.ietf.org/html/draft-nottingham-json-home-02.
        <link>http://tools.ietf.org/html/draft-nottingham-json-home-02</link></bibliomixed>


    <bibliomixed xml:id="draft-nottingham-http-problem-04" xreflabel="Problem Details for HTTP APIs">
      <emphasis role="ital">Problem Details for HTTP APIs</emphasis>,
      http://datatracker.ietf.org/doc/draft-nottingham-http-problem/.
        <link>http://datatracker.ietf.org/doc/draft-nottingham-http-problem/</link></bibliomixed>


    <bibliomixed xml:id="rfc3023" xreflabel="XML Media Types">
      <emphasis role="ital">XML Media Types</emphasis>, IETF RFC 3023, MURATA Makoto (FAMILY Given),
      Simon St.Laurent, Daniel Kohn. <link>http://tools.ietf.org/html/rfc3023</link></bibliomixed>
    <bibliomixed xml:id="rfc4288" xreflabel="Media Type Specifications and Registration Procedures">
      <emphasis role="ital">Media Type Specifications and Registration Procedures</emphasis>, IETF
      RFC 4288, Ned Freed, John C. Klensin.
      <link>http://tools.ietf.org/html/rfc4288</link></bibliomixed>
    <bibliomixed xml:id="rfc5839" xreflabel="Additional Media Type Structured Syntax Suffixes">
      <emphasis role="ital">Additional Media Type Structured Syntax Suffixes</emphasis>, IETF RFC
      5830, Tony Hansen, Alexey Melnikov.
      <link>http://tools.ietf.org/html/rfc4288</link></bibliomixed>
    <bibliomixed xml:id="Aristotle" xreflabel="Does REST need a service description language">
      Aristotle Pagaltzis. <emphasis role="ital">Does REST need a service description
        language?</emphasis>, blog post, May 27, 2007.
      <link>http://plasmasturm.org/log/460/</link>.</bibliomixed>
    <bibliomixed xml:id="Corey" xreflabel="How RESTful is Your API?"> Cory House. <emphasis
        role="ital">How RESTful is your API?</emphasis>, blog post, August 26, 2012.
        <link>http://www.bitnative.com/2012/08/26/how-restful-is-your-api/</link>.</bibliomixed>
    <bibliomixed xml:id="Fowler" xreflabel="Richardson Maturity Model"> Martin Fowler. <emphasis
        role="ital">Richardson Maturity Model: steps toward the glory of REST</emphasis>, blog post,
      18 March 2010.
      <link>http://martinfowler.com/articles/richardsonMaturityModel.html</link>.</bibliomixed>
    <bibliomixed xml:id="Dare" xreflabel="What's Wrong with WADL?"> Dare Obasanjo. <emphasis
        role="ital">What's Wrong with WADL?</emphasis>, blog post, June 4, 2007.
        <link>http://www.25hoursaday.com/weblog/2007/06/04/WhatsWrongWithWADL.aspx</link></bibliomixed>
    <bibliomixed xml:id="RiP" xreflabel="REST in Practice"> Jim Webber, Savas Parastatidis and Ian
      Robinson. <emphasis role="ital">REST in Practice: Hypermedia and Systems
        Architecture</emphasis>. O'Reilly Media; 1 edition (September 24, 2010). ISBN-13:
      978-0596805821. </bibliomixed>

    <bibliomixed xml:id="RWS" xreflabel="RESTful Web Services"> Leonard Richardson, Sam Ruby
        <emphasis role="ital">RESTful Web Services</emphasis>. O'Reilly Media; Dec 17, 2008f.
      ISBN-13: 978-0596554606.</bibliomixed>

    <bibliomixed xml:id="sedola" xreflabel="Sedola">Erik Wilde. <emphasis role="ital">Service
        Documentation Language</emphasis>
      <link>https://github.com/dret/sedola/</link>
    </bibliomixed>

    <bibliomixed xml:id="Fielding2000"
      xreflabel="Architectural Styles and the Design of Network-based Software Architectures, PhD Dissertation Thesis."
      > Roy Thomas Fielding, <emphasis role="ital">Architectural Styles and the Design of
        Network-based Software Architectures, PhD Dissertation Thesis</emphasis>, University of
      California, Irvine © 2000.
        <link>http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm.</link></bibliomixed>

    <bibliomixed xml:id="RSDL1" xreflabel="RESTful Service Description
    Language (Ovirt)">RESTful Service Description Language
    (RSDL). Michael Pasternak, Red Hat. Available at
    <link>http://www.ovirt.org/RSDL</link>.</bibliomixed>

    <bibliomixed xml:id="RSDL2" xreflabel="RESTful Service Description
    Language (EMC)">Jonathan Robie, Rob Cavicchio, Rémon Sinnema and
    Erik Wilde. <emphasis role="ital">RESTful Service Description
    Language (RSDL): Describing RESTful Services Without Tight
    Coupling.</emphasis> Presented at Balisage: The Markup Conference
    2013, Montréal, Canada, August 6 - 9, 2013. In Proceedings of
    Balisage: The Markup Conference 2013. Balisage Series on Markup
    Technologies, vol. 10
    (2013). doi:10.4242/BalisageVol10.Robie01.</bibliomixed>

  </bibliography>
</article>
